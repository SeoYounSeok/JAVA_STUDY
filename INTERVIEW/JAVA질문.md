##### 객체지향프로그래밍이란?
```
현실 세계의 사물같은 객체를 만들고, 객체에서 필요한 특징을 뽑아 프로그래밍 수행하는 방법으로 
객체지향 프로그래밍의 4가지 특징을 이용하여 코드의 재사용을 줄이고 유지보수 비용을 감소시킨다는 장점이 있습니다.
```
##### 객체지향 프로그래밍 4가지 특징
```
1. 추상화
   - 클래스들의 공통적인 특성(변수, 메소드)를 묶어 표현하는 것을 말합니다.

2. 캡슐화
   - 실제로 구현 부분을 외부에 드러나지 않게 하는 것입니다.
   - 외부에 노출할 필요가 없는 정보들은 은닉
   - 데이터를 외부에서 직접 접근하지 않고, 함수를 통해서만 접근합니다.
   
3. 상속성
   - 부모 클래스가 가진 특징(함수, 데이터)를 자손 클래스가 그대로 물려받습니다.
   - 이미 작성된 클래스를 받아서 새로운 클래스를 생성합니다.
   - 상속은 캡슐화를 유지, 클래스의 재사용이 용이하도록 합니다.

4. 다형성
   - 같은 형태지만 다른 기능을 하는 것
   - 오버라이딩 : 상위 클래스가 가지고 있는 메서드를 하위 클래스에서 재정의해서 사용합니다.
   - 오버로딩 : 하나의 클래스에서 메소드 이름은 같지만, 매게변수, 파라미터가 다른 것입니다.
```
##### 객체지향 설계 5대 원칙
```
1. 단일 책임의 원칙 : SRP (Single Responsibility Principle)
- 해당 클래스가 제공하는 모든 서비스는 단 하나의 책임을 수행하는데 집중해야 한다.

2. 개방폐쇄의 원칙 : OCP (Open Close Principle)
- 기존 구성요소는 수정이 일어나지 않아야하며, 쉽게 확장이 기능하여 재사용할 수 있어야 한다.


3. 리스코브 치환의 원칙 : LSP (the Liskov Substitution Principle)
- 일반화 관계에 대한 이야기며, 자식클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야한다.

4. 인터페이스 분리의 원칙 : ISP (Interface Segregation Principle)
- 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙 / 꼭 필요한 인터페이스만 상속하여 사용하자는 의미

5. 의존성 역전의 원칙 : DIP (Dependency Inversion Principle)
- 상위 모듈은 하위 모듈에 의존해서는 안된다. 둘 다 추상화에 의존해야 한다.

```

##### 추상 클래스와 인터페이스의 차이
```
추상 클래스는 abstract로 지시자로 정의되며, 추상 메소드가 하나 이상 포함되는 클래스입니다.
인터 페이스는 interface 지시자로 정의하며, 모든 메소드가 추상메소드로 정의할 수 있습니다. 
(자바 8버전 에서는 default 키워드를 이용해서 일반 메소드 구현이 가능하다.)

추상 클래스와 인터페이스의 차이는 그 존재의 목적에 있습니다.
추상 클래스는 상속받아서 기능을 재활용하고 확장시키는데, 
인터페이스는 함수의 구현을 강제해서 구현한 객체들이 같은 동작을 하는 것을 보장하는 것에 목적이 있습니다.

인터페이스는 다중 상속을 지원합니다.
```
##### 객체지향, 함수형의 차이
```
데이터(상태)를 다루는 개념과, '간결한 코드 작성'에 대한 관점 차이가 있다. ★★★★★

객체지향 프로그래밍의 경우, 클래스 디자인과 객체들의 관계를 중심으로 코드 작성이 이루어 진다.
따라서, 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있다.
특히 멤버변수가 어떤 상태를 가지고 있는가에 따라 겨로가가 달라진다.

함수형 프로그래밍의 경우, 값은 연산 및 결과 도출 중심으로 코드 작성이 이루어진다.
함수 내부에서 인자로 받은 값을 별도로 저장하지 않고, 간결한 과정으로 처리하고 매핑하는데 주목적으로 둔다.
```

##### 오버로딩 오버라이딩
```
* 오버로딩
  - 같은 이름의 메소드이며, 매개변수의 갯수나 타입이 다른 함수를 정의하는 것을 의미합니다.

* 오버라이딩
  - 상위 클래스의 매서드를 하위 클래스에서 재정의 하는 것입니다.
  - 매서드의 이름은 물론 파라미터의 갯수나 타입도 동일해야 하며, 주로 상위 클래스의 동작을 상속받은 하위 클래스에서 변경하기 위해 사용합니다.
```
##### 자바 애플리케이션, JVM 실행 과정
```
1. 컴파일러가 자바 소스를 바이트 코드로 변환합니다.
2. Class Loader 가 바이트 코드를 런타임 데이터 영역에 로드 시킵니다.
3. 로딩된 바이트 코드가 실행엔진에 의해서 샐행되게 됩니다.
```
##### 자바 메모리 구조
```
자바의 메모리 구조는 크게 5가지 영역으로 구분되는데요.
우선 스레드마다 PC Register, JVM Stack, Native Method Stack 이 있습니다.
그리고 스레드 공통으로는 Heap과 Method Aread. 가 있습니다.
1. PC Register는 현재 수행중인 JVM 명령어가 들어가있습니다.

2. JVM Stack 은 프로그램 실행과정에서 임시로 할당되었다가
   메서드를 빠져나가면 바로 소멸되는 데이터를 저장하기 위한 영역이다. 
   호출된 메소드의 매개변수, 지역변수, 리턴정보들이 저장됩니다. 

3. Native Methode Stack은 JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간으로
   바이트코드가 아닌 기계어로 작성된 프로그램을 실행시키는 영역이다.
   커널이 스택을 잡아 독자적으로 프로그램을 실행시킨다.

4. Method Area 는 클래스 별로 전역변수, 정적변수, 메소드 정보들이 저장되게 됩니다.

5. 마지막으로, Heap 영역은 런타임 중 생성되는 객체들이 동적으로 할당되는 곳입니다.
   Heap에 저장된 인스턴스가 참조되지 않거나 더 이상 사용되지 않을 때 GC가 소멸시킨다.
```
##### 클래스 로드 방법
##### 클래스 로드 과정

##### 가비지 컬렉션이란? + 가비지 컬렉션 일어나는 과정!
```
GC는 JVM 에서 메모리를 관리해주는 모듈입니다.
Heap 메모리를 재활용하기 위해 
더 이상 참조되지 않는 객체들을 메모리에서 제거하는 모듈입니다.
개발자가 직접 메모리를 정리하지 않아도 되어서 
개발 속도가 향상되는 장점도 있지만,
Mark and Sweep 이라는 과정에서 참조되지 않는 객체를
찾는 과정이 있는데, 이 때 쓰레드가 잠시 중단되어서,
성능이 떨어진다는 단점이 있습니다.
```

##### GC 모니터링이란
```
GC 모니터링이란 JVM이 어떻게 GC를 수행하고 있는지 알아내는 과정을 말한다. 
가령 Young 영역에 있던 객체를 Old 영역으로 언제 얼마나 이동했는지, stop-the-world가 언제 일어나고 얼마동안 일어났는지 등의 정보를 알 수 있다. 
GC를 모니터링하는 이유는 JVM이 효율적으로 GC를 수행하는지 파악하고 추가적인 GC 튜닝 작업이 필요한지 확인하기 위해서다. 
GC 모니터링으로 파악한 정보를 바탕으로 애플리케이션을 수정하거나 GC 방법을 변경(GC 튜닝)할 수 있다.
```

##### 컬렉션 프레임워크
##### Vector와 ArrayList의 차이
##### HashSet, TreeSet, LinkedHashSet 차이
##### HashMap, LinkedHashMap, HashTable, TreeMap 차이
##### Servlet 개념, 동작순서, 생명주기

##### 정적변수와 전역변수의 차이
```
전역변수(global) vs 정적변수(static) 변수로 불립니다. 
두 변수는 모두 동일한 lifetime 을 가지고 있습니다.
반면에 scope 는 서로 다릅니다.

전역변수는 해당 프로그램의 어느 함수, 어느 파일에서도 접근이 가능하다.
반면 정적변수는 변수가 선언된 파일이나 함수 내에서만 접근이 가능하다.
```
##### 접근제어자에 대해 설명
```
접근 제어자는 클래스나 변수, 메서드의 접근을 제어하기 위해 적어주는 예약어를 말합니다. 
흔히 볼 수 있는 public부터 private, protecte, default 네 가지 종류가 있습니다. 
```
![image](https://user-images.githubusercontent.com/43161245/165496787-4113b3be-c246-4cad-bfa9-a944f4d02050.png)

##### 접근제어자 사용하는 이유
```
이렇게 접근 제어자를 사용하는 이유는 보안 때문이라고 할 수 있습니다. 
만약에 웹사이트에서 아이디와 비밀번호 같은 중요한 정보를 public 변수에 저장을 한다면 아무데서나 직접적으로 접근하여 그 값을 변경할 수 있기 때문에 노출되기 쉽습니다. 
이런 중요한 변수들은 대부분 private를 붙여줍니다.

 또한 여러 사람들과 함께 프로그램을 만들다 보면 다른 사람이 내가 만든 중요한 변수나 메서드를 무분별하게 사용하여 값을 변경할 수 있는데, 
 이를 막기 위해 상황에 맞는 접근 제어자를 사용합니다.
 
 이렇게 중요한 변수와 메서드에 접근 제어자를 이용해 사용 범위를 지정해주면 완성도가 높은 프로그램을 완성할 수 있습니다.
```

##### 직렬화(Serialize)란?
```
객체의 직렬화는 객체의 내용을 바이트 단위로 변환하여 파일 또는 네트워크를 통해서 스트림(송수신) 이 가능하도록 하는 것을 의미한다.

* 장점
  - 객체 내용을 입출력형식에 구애받지 않고 객체를 파일에 저장함으로써 영속성을 제공합니다.
  - 객체를 네트워크를 통해 손쉽게 교환할 수 있다.
```
##### Wrapper Class
```
자바의 자료형은 크게 기본 타입(primitive type)과 참조 타입(reference type)으로 나누어집니다.
대표적으로 기본 타입은 char, int, float, double, boolean 등이 있고 참조 타입은 class, interface 등이 있다.
프로그래밍을 하다 보면 기본 타입의 데이터를 객체로 표현해야 하는 경우가 종종 있습니다. ★★★★★

참조형은 참조 주소를 가리키는 데이터 타입이고, 기본형은 실제 값을 갖는 데이터 타입이다.

기본 자료타입(primitive type)을 객체로 다루기 위해서 사용하는 클래스들을 래퍼 클래스(wrapper class)라고 합니다.
```
![image](https://user-images.githubusercontent.com/43161245/165503761-bc5a777c-4dcd-402e-8c55-3adc2ff2c4e2.png)

##### source code
```
Integer number1 = new Integer(10);
Integer number2 = new Integer(10);
int number3 = 10;

System.out.println("래퍼클래스 == 기본타입 : " + (number1 == number3));          // true
System.out.println("래퍼클래스.equals(기본타입) : " + (number1.equals(number3)));	// true
		
System.out.println("래퍼클래스 == 래퍼클래스 : " + (number1 == number2));           // false
System.out.println("래퍼클래스.equals(래퍼클래스) : " + (number1.equals(number2))); // true
```

##### String은 래퍼클래스인데 == 비교시 값 같게 나오는 이유
```
ㅈ래퍼 객체는 내부의 값을 비교하기 위해 == 연산자를 사용할 수 없습니다.
이 연산자는 내부의 값을 비교하는 것이 아니라, 객체의 참조 주소를 비교하기 때문입니다.
비교 대상인 래퍼는 객체이므로 서로의 참조 주소가 다릅니다.
객체끼리의 비교를 하려면 내부의 값만 얻어 비교해야 하기 때문에 equals 를 사용해야 합니다.

래퍼 클래스와 기본자료형과의 비교는 == 연산과 equals 연산 모두 가능합니다.
그 이유는 컴파일러가 자동으로 오토박싱과 언박싱을 해주기 때문입니다.
```

##### 제네릭이란?
```
- 제네릭은 클래스 내부에서 지정하는 것이 아닌, 외부에서 사용자에 의해 지정되는 것을 의미한다.
```
##### final이란?
```

```
##### 자바 버전별 차이(버전 업의 차이)
