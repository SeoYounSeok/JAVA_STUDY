##### 스프링이란? (Spring Core)
```
자바의 오픈소스 어플리케이션 경량 프레임워크 중 하나로 
스프링의 기본철학은 특정 기술에 종속되지 않고,
객체를 관리할 수 있는 프레임워크를 제공하는 것입니다.
그래서 컨테이너로 자바 객체를 관리하면서,
의존성 주입과 제어의 역전을 통해 결합도를 낮추게 됩니다.
```
##### DI란?
```
DI는 Dependency Injection의 약자로, 의존성 주입을 의미합니다.
객체간의 의존 관계를 미리 설정해두면 스프링 컨테이너가 의존관계를 자동으로 연결해줍니다. 
이렇게 되면 직접 의존하는 객체를 생성하거나 검색해서 가져올 필요 없어서 결합도가 낮아지는 장점이 있습니다. 
DI, 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로 부터 필요한 객체를 받아서 사용하는 것이다.
```
##### IoC란?
```
Inversion of Control의 약자로 제어의 역전을 의미합니다. 
제어권이 사용자에 있지 않고, 프레임워크에 있어서 필요에 따라서 사용자의 코드를 호출하게 되는 것 입니다.
스프링에서는 인스턴스의 생성부터 소멸까지 
개발자가 아닌 컨테이너에서 대신 관리하게 됩니다.
```
##### 프레임워크와 라이브러리
```
프레임워크 : 특정 프로그램을 개발하기 위해서 여러 요소들과 메뉴얼인 룰을 제공하는 프로그램,
라이브러리 : 프로그램을 개발하기 위해 쓰는 도구들의 집합 

차이점 : 어플리케이션의 흐름을 누가 쥐고 있느냐 에 달려 있습니다. 
       프레임워크는 전체적인 흐름을 스스로가 쥐고 있으며, 사용자는 그 안에서 필요한 코드를 짜 넣으며,
       반면에 라이브러리는 사용자가 전체적인 흐름을 만들고, 라이브러리를 가져다 쓰는 것입니다.
```
##### 서블릿이란? [출처사이트:망나니개발자](https://mangkyu.tistory.com/14)
```
* 정의
  - 클라이언트의 요청을 처리하고, 그 결과를 반환하는
    Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술  
  - 간단하게, 자바를 사용하여 웹을 만들기 위해 필요한 기술
  - 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 전송 해주어야 하는데, 이러한 역할을 하는 자바 프로그램입니다.
  - 자바를 이용하여 웹 페이지를 동적으로 생성하는 서버측 프로그램
  
자바로 구현된 CGI 라고 합니다.

웹 서버가 동적인 페이지를 제공할 수 있도록 도와주는 어플리케이션이 서블릿이며, 동적인 페이지를 생성하는 어플리케이션이 CGI입니다.
```
![image](https://user-images.githubusercontent.com/43161245/165676277-041eecb8-ee51-4a87-a59e-c468c9481793.png)

```
1. 사용자(클라이언트)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송합니다.
2. 요청을 전송받은 Servlet Container는 HttpServletRequest, HttpServletReasponse 객체를 생성합니다.
3. web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
4. 해당 서블릿에서 service메소드를 호출한 후 클라이언트의 GET, POST 여부에 따라 doGet(), doPost()를 호출합니다.
5. doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보냅니다.
6. 응답이 끝나면, HttpServletRequest, HttpServletReasponse 객체를 제거합니다.
```

##### 서블릿 컨테이너
```
서블릿을 관리해주는 것입니다. 클라이언트 요청을 받아주고 응답을 할 수 있게 웹 서버와 소켓으로 통신합니다.
서블릿 객체를 생성, 초기화, 호출 종료하는 생명 주기를 관리합니다. 톰캣처럼 서블릿을 지원하는 was 를 서블릿 컨테이너라고 할 수 있습니다.

1. 웹서버와의 통신 지원
2. 서블릿 생명주기 관리
3. 멀티쓰레드 지원 및 관리
4. 선언적인 보안 관리

init() / service() / destroy()
```
##### 디스패처 서블릿이란?
```
디스패처 서블릿은 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러(Front Controller)
```
##### 디스패처 서블릿으로 인한 web.xml 역할 축소
```
과거에는 모든 서블릿을 URL 매핑을 위해 web.xml에 등록해주어야 했지만, 
dispatcher-servlet이 해당 어플리케이션으로 들어오는 모든 요청을 핸들링해주고 공통 작업을 처리해주면서,
상당히 편리하게 이용할 수 있게 되었습니다.

"디스패처 서블릿을 통해 요청을 처리할 컨트롤러를 찾아서 위임하고, 그 결과를 받아오는 구나"
```
![image](https://user-images.githubusercontent.com/43161245/165675642-b2216d11-8556-4026-831d-cc499db873b4.png)

##### JSP(JAVA Servcer Page)
```
자바 코드가 들어가 있는 HTML 코드입니다.
HTML 소스코드 속에 자바 소스코드가 들어가는 구조입니다.

```

##### AOP란? [zzang9ha 님의 블로그](https://zzang9ha.tistory.com/389)
```
AOP는 관점 지향 프로그래밍의 약자인데요. 기존의 OOP에서 기능별로 클래스를 분리했음에도 불구하고,
공통적으로 반복되는 중복코드가 발생하는데 이를 해결할 수 있도록 실행 시 비즈니스 로직의 앞과 뒤에서 원하는 지점에
해당 공통 관심사를 수행할 수 있게 한다.
```
```
AOP 필요성 - 코드

class 로그 {
  static printLog4j();
}

class 계좌이체 {
  이체() {
    로그.printLog4j();
    ...
  }
}

class 입출금 {
  입금() {
    로그.printLog4j();
    ...
  }
}

class 이자계산 {
  이자계산() {
    로그.printLog4j();
    ...
  }
}
```

##### AOP 용어 설명
```
* Aspect
  - OOP의 클래스와 마찬가지로 AOP의 기본 모듈이다.
  - Aspect 부가기능을 정의한 어드바이스와 어드바이스를 어디에 적용할지 결정하는 포인트컷의 조합으로 구성됩니다.
  - 보통 싱글톤 형태의 오브젝트로 존재합니다.

* Target(타겟)
  - 부가기능을 부여할 대상을 의미합니다.
  - 위 구조에서 핵심기능(계좌이체, 입출금, 이자계산)을 담은 클래스 입니다.

* Advice
  - 실질적으로 부가기능을 담은 구현체를 의미합니다.
  - 어드바이스의 경우 타겟 오브젝트에 종속되지 않기 때문에 순수하게 부가기능에만 집중할 수 있습니다.

* Join Point(조인 포인트)
  - 어드바이스가 적용될 수 있는 위치

* Pointcut(포인트컷)
  - 부가기능이 적용될 대상을 선정하는 방법을 의미합니다.
  - 스프링 AOP의 조인 포인트는 메소드의 실행이므로 스프링의 포인트컷은 메소드를 선정하는 기능을 갖고 있습니다.
  - 포인트컷 표현식은 execution으로 시작하고 메서드의 Signature를 비교하는 방법을 주로 이용한다.

* Weaving
  - 포인트컷에 의해서 결정된 타켓의 조인 포인트에 부가기능(Advice)를 삽입하는 과정을 뜻한다.

* 인트로덕션
  - 타겟 클래스에 추가적인 메소드나 필드를 추가하는 기능을 의미합니다.

* 프록시
  - 클라이언트와 타겟 사이에 투명하게 존재하여 부가기능을 제공하는 오브젝트입니다.
  - DI를 통해 타겟 대신 클라이언트에게 주입되며, 클라이언트의 메소드 호출을 대신 받아 타겟에 위임해주며 부가기능을 부여합니다.
```

##### AOP 사용 경험 : 공통 로그 구현
![image](https://user-images.githubusercontent.com/43161245/165766231-73eb7810-8eff-486a-bb8f-a3ee539e0541.png)

##### 필터와 인터셉트 차이
```
- 컨트롤러에 들어가기 전 작업을 처리하기 위해 사용하는 공통점이 있지만, 호출되는 시점에서 차이가 있습니다.
- 실행되는 시점에서 차이가 있습니다.
- 필터는 DispatcherServlet 으로 요청이 가기 전에 실행 되고, 인터셉터는 Controller 로 요청이 가기 전에 실행됩니다.

* 설정 위치
- Filter는 web.xml , Interceptor는 spring-servlet.xml
```
![image](https://user-images.githubusercontent.com/43161245/165873424-d5164673-c7ca-492d-9322-b84a5c4887f5.png)

##### 스프링 MVC 구조 흐름 [sorzzzy 블로그](https://velog.io/@sorzzzzy/Spring-Boot4-5.-%EC%8A%A4%ED%94%84%EB%A7%81-MVC-%EA%B5%AC%EC%A1%B0-%EC%9D%B4%ED%95%B4)  [코딩노트 블로그](https://codingnotes.tistory.com/28)  [hunit 블로그](https://hunit.tistory.com/189)
![image](https://user-images.githubusercontent.com/43161245/165874887-8fe6b511-e8a2-48a2-9648-e62a5467693c.png)
![image](https://user-images.githubusercontent.com/43161245/165875039-32420fa6-d52d-4237-b986-ebdc5bb2e2aa.png)
![image](https://user-images.githubusercontent.com/43161245/165875468-a4592cde-41cd-4da7-97ab-6712c6d79ba2.png)
```
1. 클라이언트의 모든 요청을 Dispatcher Servlet이라는 Servlet Class 가 받는다.

2. Dispatcher Servlet(Front Controller) 은 요청 URL 을 Handler Mapping 에게 전달하고, 
   현재 요청에 알맞는 Controoler 와 Method 에 대한 정보를 알아낸다. 

3. Dispatcher Servlet은 HandlerAdapter에게 요청 처리를 위임한다. 

4. HandlerAdapter는 Controller 와 해당 메서드를 실행한다.

5. Controller 는 비지니스 로직을 처리하고, 그 결과를 바탕으로 뷰(ex.JSP)에 전달될 객체를 Model 객체에 저장한다.
   - Dispatcher Servlet에게 View name을 리턴한다.
   - Model : Controller에서 View 로 넘겨줄 객체가 저장되는 곳
   
6. Dispatcher Servlet은 view name 을 View Resoler 에게 전달하여 View 객체를 얻는다.
   - View Resolver는 전달된 정보를 바탕으로 사용자에게 보여줄 View가 무엇인지 결정한다.

7. Dispatcher Servlet 은 View 객체에 화면 표시를 의뢰한다.

8. View 객체는 해당하는 뷰(ex. JSP, Thymeleaf)를 호출하며, 뷰는 Model 객체에서 화면 표시에 필요한 객체를 가져와 화면 표시를 처리한다.
```
![image](https://user-images.githubusercontent.com/43161245/165875069-d4d75631-ffd5-4b0e-8f9d-cdaa94b24489.png)
```
1. 웹브라우저에게 정보요청을 받은 디스패쳐서블릿은 어느 컨트롤러에 해당 요청을 전송할지 결정 

2. 디스패쳐 서블릿은 핸들러 매핑에 어느 컨트롤러를 사용할건지 물어봄. (URL로 링크)

3. 결정된 컨트롤러는 해당요청을 수행하게 됨

4. 해당요청을 처리한 컨트롤러는 디스패쳐서블릿에 결과를 보냄. 이 과정에서 Model이 생성되어 View(JSP)에서 같이 사용됨 

5. ModelAndView는 실제 JSP정보를 갖고 있지 않기 때문에 뷰리졸버가 실제 JSP이름으로 변환하여 해당 view를 검색함.

6. 검색한 결과를 View에 전송

7. View는 모든 과정에서 처리된 결과를 화면으로 표현함

8. 마지막으로 디스패쳐서블릿이 웹브라우저에 최종결과를 출력
```


##### 스프링과 스프링 부트 차이
```
1. 라이브러리 관리 자동화
  - spring boot-start 를 통해 라이브러리 의존성을 간단히 처리할 수 있다.

2. 설정의 자동화
  - 프로젝트에 추가된 라이브러리 기반으로 실행환경을 자동 설정해준다.
  - 개발에 필요한 라이브러리들을 추가하면 관련 스프링 설정을 자동으로 처리해준다.

3. 라이브러리 버전 자동 관리
  - 스프링 부트 버전에 해당하는 스프링 라이브러리와 서드파티 라이브러리를 호환버전으로 제공
  - 라이브러리 버전 문제를 겪을 필요가 없고, XML 설정 과정이 필요없어진다.

4. 테스팅환경 & 내장 TOMCAT
  - Junit 등 테스트 관련 라이브러리들이 포함되어 있어, 테스트케이스 작성이 쉽다.
  - Tomcat 서버를 내장하고 있어 따로 설치할 필요가 없다.
  
5. 독립적으로 실행 가능한 JAR
  - 스프링에서는 일반 자바 프로젝트를 JAR 파일로, 웹 프로젝트라면 WAR 파일로 패키징 해야한다.
  - 부트는 웹 애플리케이션 JAR 파일로 패키징하여 사용할 수 있다.
```
##### 스프링 어노테이션
```
어노테이션은 메타데이터, 코드를 설명하기 위한 데이터라고 정의할 수 있다.
@를 이용한 주석, 자바 코드에 주석을 달아 특별한 의미를 부여한 것이다.

컴파일러가 특정 오류를 억제하도록 지시하는 것과 같이
프로그램 코드의 일부가 아닌 프로그램에 대한 데이터를 제공, 코드에 정보를 추가하는 정형화된 방법이다.

@Override 어노테이션 처럼 컴파일러를 위한 정보를 제공하기 위한 용도이다.
@Controller 어노테이션 처럼 런타임에 리플렉션을 이용해 특수 기능을 추가하는 위한 용도이다.
```
##### 어노테이션 종류
##### 스프링 버전별 기능
##### MVC 1과 MVC 2의 차이
##### ORM
```
Object Relational Mappings 의 약자로 관계형 데이터베이스를 OOP언어로 변환해주는 기술입니다.
그래서 비즈니스 코드가 DB 테이블에 바로 접근하게 도와줍니다.
```
##### JPA
```
JPA는 ORM을 위해서 자바에서 제공하는 API입니다.
자바 객체와 DB 테이블을 매핑하는데요. 구현체로는 하이버네이트가 있습니다.
```
##### ORM, JPA, Hibernate 장단점
```
비즈니스 로직에 집중하고 객체중심의 개발을 할 수 있게 됩니다.
그리고 메소드를 호출하는 것만으로 쿼리를 수행해서
생산성을 향상되고, 유지보수 비용이 줄어듭니다.
그리도 특정 DB에 의존하지 않게 됩니다.

하지만 직접 SQL을 호출하는 것보다 조금 느립니다.
그리고 복잡한 쿼리같은 것은 메소드로 처리가 힘들다는 단점이 있습니다.(다중 조인)
```
##### SQL Mapper
```
- Object와 SQL 필드를 매핑하여 데이터를 객체화 하는 기술
- SQL문을 직접 작성하고 쿼리 수행결과를 어떠한 객체에 매핑하여 줄 지 바인딩하는 방법, 즉 SQL 의존적인 방법
ex) JdbcTemplate, Mabatis
```
##### Mybatis란?
```
SQL 을 xml 파일로 분리하여 관리하고, SQL결과와 객체 인스턴스의 매핑을 도와주는 역할을 수행한다.
동적쿼리를 지원하여 다이나믹하게 변경되는 쿼리 작성가능.

단점
- SQL을 개발자가 직접 작성하는 문제
- DBMS에 종속적인 문제
- 비슷한 쿼리를 반복적으로 작성해야하는 문제
- 객체와 객체형 테이블 구조간 패러다임 불일치 발생
```
##### Spring Security
```
- Spring 기반의 애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크

- '인증'과 '권한'에 대한 부분을 Filter 흐름에 따라 처리

- Spring Security는 보안과 관련해서 체계적으로 많은 옵션을 제공해주기 때문에
  개발자 입장에서는 일일이 보안관련 로직을 작성하지 않아도 된다는 장점이 있다.
```
##### Mybatis, JPA 차이
##### JDBC
```
JDBC(Java Database Connectivity)는 DB에 접근할 수 있도록 JAVA에서 제공하는 API이다.
JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공합니다.

* JDBC API의 문제점
  - 쿼리를 실행하기 전과 후에 많은 코드를 작성해야한다. ex) 연결 생성, 명령문, ResultSet 닫기 등
  - 데이터베이스 로직에서 예외 처리 코드를 수행해야 한다.
  - 트랜잭션을 처리해야한다.
  - 이러한 모든 코드를 반복하는 것으로, 시간이 낭비된다.
```
##### Spring JDBC
```
JDBC 의 장점과 단순성을 그래도 유지하면서도 기존 JDBC의 단점을 극복할 수 있게 해주고,
간결한 형태의 API 사용법을 제공하며, JDBC API에서 지원되지 않는 편리한 기능을 제공.

- Spring JDBC는 반복적으로 해야하는 많은 작업들을 대신 해줌.
- Spring JDBC를 사용할 때는 실행할 SQL과 바인딩 할 파라미터를 넘겨주거나, 
  쿼리 실행 결과를 어떤 객체에 넘겨 받을지를 지정만 하면 된다.
- Spring JDBC를 사용하려면 먼저, DB 커넥션을 가져오는 DataSource 를 Bean으로 등록해야 한다.
```
##### DAO, DTO 란?
```
DAO(Data Access Object) 는 데이터베이스의 data에 접근하기 위한 객체입니다.
DataBase에 접근 하기 위한 로직 & 비지니스 로직을 분리하기 위해 사용합니다.

DTO(Data Transfer Object) 는 계층 간 데이터 교환을 하기 위해 사용하는 객체로, 
DTO는 로직을 가지지 않는 순수한 데이터 객체(getter & setter 만 가진 클래스)입니다.

VO(Value Object) 값 오브젝트로써 값을 위해 쓰입니다. 
read-Only 특징(사용하는 도중에 변경 불가능하며 오직 읽기만 가능)을 가집니다.
```
##### 동시성
```
한 순간에 여러가지 일이 아니라, 짧은 전환으로 여러가지 일을 동시에 처리하는 것처럼 보이는 것.
```
